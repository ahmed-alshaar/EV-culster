<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EV Navigation (Fixed)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
  // Maneuvers queue with sensible progression
  const maneuvers = [
    { id:'exit-right', label:'Exit right', arrow:'right', dist:350 },
    { id:'turn-left', label:'Turn left', arrow:'left', dist:1200 },
    { id:'continue', label:'Continue', arrow:'up', dist:2800 }
  ];
  let current = 0;

  // State
  let distanceM = maneuvers[0].dist;
  let speedKmh = 78; // UI speed; we smooth and slow when close

  // Elements
  const distEl = document.getElementById('distance');
  const speedEl = document.getElementById('speed');
  const nextExitEl = document.getElementById('next-exit');
  const centerArrowEl = document.getElementById('center-arrow');
  const laneArrowEl = document.getElementById('lane-arrow');
  const laneLabelEl = document.getElementById('lane-label');
  const leftSignal = document.getElementById('left-signal');

  function iconFor(arrow){
    if(arrow==='right') return 'fa-arrow-right';
    if(arrow==='left') return 'fa-arrow-left';
    return 'fa-arrow-up';
  }

  function renderCenter(){
    // update central arrow to match current maneuver
    centerArrowEl.className = 'fa-solid ' + iconFor(maneuvers[current].arrow) + ' text-7xl md:text-8xl text-cyan-400';
    // lane indicator
    laneArrowEl.className = 'fa-solid ' + iconFor(maneuvers[current].arrow) + ' text-white text-lg';
    laneLabelEl.textContent = maneuvers[current].arrow==='right' ? 'EXIT RIGHT' : maneuvers[current].arrow==='left' ? 'TURN LEFT' : 'STRAIGHT';
    // flash only when turning
    if(maneuvers[current].arrow!=='up'){
      document.getElementById('lane-indicator').classList.add('flash');
    } else {
      document.getElementById('lane-indicator').classList.remove('flash');
    }
  }

  function renderUpcoming(){
    // first item distance equals current central distance
    nextExitEl.textContent = Math.max(1, Math.round(distanceM));
  }

  function advance(){
    current = Math.min(current+1, maneuvers.length-1);
    distanceM = maneuvers[current].dist;
    renderCenter();
  }

  // initial render
  speedEl.textContent = speedKmh;
  renderCenter();
  renderUpcoming();
  distEl.textContent = Math.round(distanceM);

  // Countdown with UI pacing: slow when close to junction
  let last = performance.now();
  function tick(now){
    const dt = (now - last)/1000; last = now;
    // simulate slowing near junction
    const targetKmh = distanceM < 150 ? 42 : speedKmh;
    const easedKmh = 0.9*Number(speedEl.textContent) + 0.1*targetKmh; // smooth
    speedEl.textContent = Math.round(easedKmh);

    // UI pacing factor so it doesn't burn down too fast
    const mps = (easedKmh * 1000/3600) * 0.45; // 45% real speed for legibility
    distanceM = Math.max(0, distanceM - mps * dt);

    // display
    const shown = Math.max(0, Math.round(distanceM));
    distEl.textContent = shown;
    renderUpcoming();

    if (shown <= 0){
      // small pop and move to next maneuver
      distEl.style.transform = 'scale(1.12)';
      setTimeout(()=>{ distEl.style.transform = 'scale(1)'; }, 160);
      if(current < maneuvers.length-1){ advance(); }
      else { cancelAnimationFrame(anim); return; }
    }
    anim = requestAnimationFrame(tick);
  }
  let anim = requestAnimationFrame(tick);

  // Debug helpers
  window.setSpeed = (kmh)=>{ speedKmh = Math.max(0, Number(kmh)||0); };
  window.skip = ()=>{ distanceM = 0; };
</script>

</body>
</html>
